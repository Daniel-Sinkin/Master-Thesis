% chapters/04_sections/integration_and_build_system.tex
\section{Integration and Build System}\label{sec:build-system}

The implementation is integrated as a reproducible CUDA/C++ project with clear
separation between benchmark harness and kernel library, with profiling scripts
kept independent.
This structure is necessary to compare optimisation variants consistently across
multiple datasets and precision modes.

\subsection{Build Configuration}

All kernels target Ampere compute capability (\texttt{sm\_80}) and are compiled
in release mode with architecture-specific optimisation enabled. The build
configuration records:

\begin{itemize}
  \item compiler and CUDA toolkit versions,
  \item target architecture flags,
  \item enabled precision modes and feature toggles,
  \item linked baseline libraries (cuBLAS, cuTENSOR, cuBLASDx where used).
\end{itemize}

This metadata is logged with benchmark output so each result can be traced to a
specific binary configuration.

\subsection{Runtime Integration}

Kernel entry points are exposed through a common interface that supports:

\begin{enumerate}
  \item baseline execution,
  \item custom unfused kernel execution,
  \item fused-kernel execution paths.
\end{enumerate}

Using a unified interface allows controlled A/B testing with minimal host-side
differences between variants.
